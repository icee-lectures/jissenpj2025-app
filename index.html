<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <title>A-Frame VR 移動テスト</title>
    <script src="https://aframe.io/releases/1.5.0/aframe.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/aframe-extras@7.0.0/dist/aframe-extras.loaders.min.js"></script>
    <script>
      // 隙間を20分割し、クリック中にカーソルが重なった部分を埋める
      let isFilling = false;
      AFRAME.registerComponent('fill-gap-on-mousedown', {
        schema: {
          index: {type: 'int'},
          count: {type: 'int', default: 20}
        },
        init: function () {
          var el = this.el;
          var data = this.data;
          var scene = document.querySelector('a-scene');
          this.filled = false; // ← thisに持たせる

          // ピースの埋め処理
          function fill() {
            if (el.components['fill-gap-on-mousedown'].filled) return;
            var pieceWidth = 0.5 / data.count;
            var x = -0.25 + pieceWidth / 2 + pieceWidth * data.index;
            var filler = document.createElement('a-box');
            filler.setAttribute('position', `${x} 1.11 -3.96`);
            filler.setAttribute('width', pieceWidth);
            filler.setAttribute('height', '0.02');
            filler.setAttribute('depth', '0.05');
            filler.setAttribute('color', '#FF0000'); // 赤色
            scene.appendChild(filler);
            el.components['fill-gap-on-mousedown'].filled = true;
            // 0.1秒後にfillerを黒くする
            setTimeout(() => {
              filler.setAttribute('color', '#000000');
            }, 100);
            // 隙間を埋める処理の直後
            spawnParticles(x, 1.11, -3.96); // x, y, zは埋めた位置に合わせて
           
            // カウントを増やして表示を更新
            fillCount++;
            fillCountText.setAttribute('value', `埋めた数: ${fillCount} 個 / ${data.count} 個`);

            // タイム計測
            if (fillCount === 1) {
              // 録画開始
              recording = true;
              recordedFrames = [];
              startTime = performance.now();
              endTime = null;
              timerRunning = true;
              requestAnimationFrame(updateTimer);

              // sideRecordingも開始
              sideRecording = true;
              sideRecordedFrames = [];
            }
            if (fillCount === data.count) {
              // 録画終了
              recording = false;
              endTime = performance.now();
              timerRunning = false;
              const seconds = ((endTime - startTime) / 1000).toFixed(2);
              timerText.setAttribute('value', `タイム: ${seconds} 秒`);
              // 最終速度（分母に+0.5秒を加える）
              const speed = data.count / (((endTime - startTime) / 1000) + 0.5);
              speedText.setAttribute('value', `速度: ${speed.toFixed(2)} 個/s`);

              // sideRecordingも終了
              sideRecording = false;
            }
          }

          // 外部から呼び出せる
          this.fillByStick = fill;

          el.addEventListener('mouseenter', function () {
            if (isFilling) fill();
          });

          el.addEventListener('mousedown', function () {
            isFilling = true;
            fill();
          });

          // グローバルでmouseupを監視して埋めモード終了
          window.addEventListener('mouseup', function () {
            isFilling = false;
          });

          // VRコントローラー対応
          el.addEventListener('triggerdown', function () {
            isFilling = true;
            fill();
          });
          window.addEventListener('triggerup', function () {
            isFilling = false;
          });
        }
      });
    </script>
    <script>
      // 棒の先端がピースに触れたら埋める
      let isTouchFilling = false;
      AFRAME.registerComponent('stick-tip-listener', {
        init: function () {
          this.el.addEventListener('collidestart', function (evt) {
            // evt.detail.body.elは触れた相手
            if (evt.detail.body.el && evt.detail.body.el.components['fill-gap-on-mousedown']) {
              evt.detail.body.el.components['fill-gap-on-mousedown'].fillByStick();
            }
          });
        }
      });
    </script>
  </head>
  <body>
    <a-scene>
      <!-- カメラと移動コントロール + カーソルをa-scene内の最初の方に追加 -->
      <a-entity camera look-controls="pointerLockEnabled: true" wasd-controls="acceleration: 20" position="0 2.0 -2" camera-z-limit>
        <a-cursor></a-cursor>
      </a-entity>

      <!-- 地面（緑色） -->
      <a-plane rotation="-90 0 0" width="100" height="100" color="#228B22"></a-plane>

      <!-- 四つ足の机 -->
<!--
<a-box position="0 1 -4" width="2" height="0.1" depth="1" color="#8B5A2B"></a-box>
<a-box position="-0.85 0.5 -4.45" width="0.1" height="1" depth="0.1" color="#A0522D"></a-box>
<a-box position="0.85 0.5 -4.45" width="0.1" height="1" depth="0.1" color="#A0522D"></a-box>
<a-box position="-0.85 0.5 -3.55" width="0.1" height="1" depth="0.1" color="#A0522D"></a-box>
<a-box position="0.85 0.5 -3.55" width="0.1" height="1" depth="0.1" color="#A0522D"></a-box>
-->

      <!-- 机の上の2枚の板（間に小さい隙間） -->
      <a-box position="0 1.11 -4.03" width="0.5" height="0.02" depth="0.1" color="#D2B48C"></a-box>
      <a-box position="0 1.11 -3.89" width="0.5" height="0.02" depth="0.1" color="#DEB887"></a-box>
      <!-- 隙間クリック用の透明オブジェクトを20分割で配置 -->
      <a-entity id="gap-colliders"></a-entity>

      <!-- 空（青色） -->
      <a-sky color="#87CEEB"></a-sky>

      <a-entity id="rightHand" laser-controls="hand: right" raycaster="objects: [clickable]">
        <!-- 棒本体 -->
        <a-cylinder position="0 0 -0.3" radius="0.01" height="0.6" color="#888"></a-cylinder>
        <!-- 先端の球体（コリジョン判定用） -->
        <a-sphere id="stickTip" position="0 0 -0.3" radius="0.03" color="#F00"
                  dynamic-body="shape: sphere; mass: 0"
                  stick-tip-listener></a-sphere>
      </a-entity>
      <a-entity laser-controls="hand: left" raycaster="objects: [clickable]"></a-entity>

      <!-- お手本ボタン -->
      <a-box id="demo-btn" position="0.5 1.16 -4" width="0.2" height="0.04" depth="0.1" color="#66ccff" class="clickable">
        <a-text value="お手本" align="center" color="#000" position="0 0.03 0"></a-text>
      </a-box>
      <!-- ボタン名ラベル（y座標を上げてzを-3.95にして浮かせる） -->
      <a-text value="お手本を再現" align="center" color="#000" position="0.5 1.30 -3.95" width="1"></a-text>

      <!-- リセットボタン -->
      <a-box id="reset-btn" position="0.8 1.16 -4" width="0.2" height="0.04" depth="0.1" color="#ffcc00" class="clickable">
        <a-text value="リセット" align="center" color="#000" position="0 0.03 0"></a-text>
      </a-box>
      <a-text value="やり直し" align="center" color="#000" position="0.8 1.30 -3.95" width="100"></a-text>

      <!-- リプレイボタン -->
      <a-box id="replay-btn" position="0.5 1.16 -3.8" width="0.2" height="0.04" depth="0.1" color="#ff8888" class="clickable">
        <a-text value="リプレイ" align="center" color="#000" position="0 0.03 0"></a-text>
      </a-box>
      <a-text value="動きを再生" align="center" color="#000" position="0.5 1.30 -3.75" width="1"></a-text>

      <!-- 埋めた数を表示するテキスト（例：画面左上） -->
      <a-text id="fill-count-text" value="埋めた数: 0 / 20" position="-0.9 2.0 -4.5" color="#222" width="2"></a-text>
      <!-- タイム表示用テキスト -->
      <a-text id="timer-text" value="タイム: 0.00秒" position="-0.9 1.8 -4.5" color="#222" width="2"></a-text>
      <!-- 速度表示用テキスト -->
      <a-text id="speed-text" value="速度: 0.00 個/s" position="-0.9 1.6 -4.5" color="#222" width="2"></a-text>

      <!-- グラフ用canvas（非表示） -->
      <canvas id="speed-graph" width="300" height="150" style="display:none"></canvas>
      <!-- グラフ表示用a-plane（画面右上あたりに表示例） -->
      <a-plane id="graph-plane" position="0.8 2.0 -4.5" width="0.6" height="0.3" material="side:double"></a-plane>

      <!-- 机の上に仮想カメラを設置 -->
      <a-entity id="table-cam" camera="active: false" position="0 1.3 -3.97" rotation="-90 0 0"></a-entity>
      <a-plane id="screen" position="1.5 1.5 -4" width="1" height="0.75" tablecam-to-screen></a-plane>

      <!-- 横からのカメラ（隙間の真横から撮影） -->
      <a-entity id="side-cam" camera="active: false" position="-0.3 1.13 -3.96" rotation="0 -90 0"></a-entity>
      <!-- 横カメラの映像を映すスクリーン（例：左側に表示） -->
      <a-plane id="side-screen" position="-1.5 1.5 -4" width="1" height="0.75" sidecam-to-screen></a-plane>

      <!-- ...a-scene内の好きな位置に追加... -->
<a-entity stl-model="src: url(Part1.STL)" position="-0.25 1.13 -4" scale="0.02 0.02 0.02" color="#ff8800"></a-entity>
<a-entity stl-model="src: url(Part2.STL)" position="0.25 1.13 -4" scale="0.02 0.02 0.02" color="#0088ff"></a-entity>
<!-- 机の上あたりにGLBモデルを追加 -->
<a-entity
  id="deskModel"
  gltf-model="deskModel.glb"
  position="0 1.15 -4.2"
  scale="1.5 1.5 1.5">
</a-entity>
<!-- arkModelの追加 -->
<a-entity
  id="arkModel"
  gltf-model="ark.blend.glb"
  position="0.53 1.52 -4.45"
  scale="0.01 0.01 0.01">
</a-entity>
    </a-scene>
    <script>
      // 隙間部分を20分割して透明オブジェクトを配置（x方向に分割）
      const count = 70; // 20分割ではなく28分割に変更
      // 隙間クリック用の透明オブジェクトを配置するエンティ
      const gapColliders = document.getElementById('gap-colliders');

      // ★ここでグローバル変数を宣言
      let fillCount = 0;
      let startTime = null;
      let endTime = null;
      let timerRunning = false;
      const fillCountText = document.getElementById('fill-count-text');
      const timerText = document.getElementById('timer-text');
      const speedText = document.getElementById('speed-text');
      let speedHistory = [];
      let timeHistory = [];
      const graphCanvas = document.getElementById('speed-graph');
      const graphCtx = graphCanvas.getContext('2d');
      const graphPlane = document.getElementById('graph-plane');

      // タイマー更新用関数
      function updateTimer() {
        if (!timerRunning) return;
        if (startTime !== null && endTime === null) {
          const now = performance.now();
          const seconds = (now - startTime) / 1000;
          timerText.setAttribute('value', `タイム: ${seconds.toFixed(2)} 秒`);
          // 速度計算（分母に+0.25秒を加える）
          const speed = (seconds + 0.25) > 0 ? fillCount / (seconds + 0.25) : 0;
          speedText.setAttribute('value', `速度: ${speed.toFixed(2)} 個/s`);

          // グラフ用履歴を記録（0.05秒ごとに記録例）
          if (
            timeHistory.length === 0 ||
            seconds - timeHistory[timeHistory.length - 1] > 0.05
          ) {
            timeHistory.push(seconds);
            speedHistory.push(speed);
            updateGraph();
          }

          requestAnimationFrame(updateTimer);
        }
      }

      // グラフ更新関数
      function updateGraph() {
        // グラフ背景
        graphCtx.fillStyle = "#fff";
        graphCtx.fillRect(0, 0, graphCanvas.width, graphCanvas.height);

        // 軸
        graphCtx.strokeStyle = "#222";
        graphCtx.beginPath();
        graphCtx.moveTo(30, 10);
        graphCtx.lineTo(30, 140);
        graphCtx.lineTo(290, 140);
        graphCtx.stroke();

        // 軸ラベル
        graphCtx.fillStyle = "#222";
        graphCtx.font = "12px sans-serif";
        graphCtx.fillText("個/s", 0, 20);
        graphCtx.fillText("時間(s)", 230, 150);

        // データがなければreturn（ここでreturnしてOK）
        if (speedHistory.length < 2) return;

        // 最大値取得
        const maxSpeed = Math.max(...speedHistory, 1);
        const maxTime = timeHistory[timeHistory.length - 1];

        // グラフ線
        graphCtx.strokeStyle = "#0077cc";
        graphCtx.beginPath();
        for (let i = 0; i < speedHistory.length; i++) {
          const x = 30 + (260 * timeHistory[i] / Math.max(maxTime, 1));
          const y = 140 - (120 * speedHistory[i] / maxSpeed);
          if (i === 0) graphCtx.moveTo(x, y);
          else graphCtx.lineTo(x, y);
        }
        graphCtx.stroke();

        // テクスチャ更新
        const mesh = graphPlane.getObject3D('mesh');
        if (mesh && mesh.material.map) {
          mesh.material.map.needsUpdate = true;
        }
      }

      for (let i = 0; i < count; i++) {
        // 1ピースのwidth
        const pieceWidth = 0.5 / count;
        // このピースの中心x座標
        const x = -0.25 + pieceWidth / 2 + pieceWidth * i;
        const box = document.createElement('a-box');
        box.setAttribute('position', `${x} 1.11 -4`);
        box.setAttribute('width', pieceWidth);
        box.setAttribute('height', '0.03');
        box.setAttribute('depth', '0.18');
        box.setAttribute('opacity', '0');
        box.setAttribute('transparent', 'true');
        box.setAttribute('class', 'clickable');
        box.setAttribute('fill-gap-on-mousedown', `index: ${i}; count: ${count}`);
        gapColliders.appendChild(box);
      }

      // リセットボタンの処理
      document.getElementById('reset-btn').addEventListener('click', function () {
        // 埋めたa-box（fill-gap-on-mousedownで生成されたもの）を削除
        document.querySelectorAll('a-box').forEach(box => {
          // 生成されたfillerはcolor="#FF0000"または"#000000"
          const color = box.getAttribute('color');
          if (color === '#FF0000' || color === '#000000') {
            box.parentNode.removeChild(box);
          }
        });
        // 各fill-gap-on-mousedownのfilled状態もリセット
        document.querySelectorAll('[fill-gap-on-mousedown]').forEach(el => {
          if (el.components['fill-gap-on-mousedown']) {
            el.components['fill-gap-on-mousedown'].filled = false;
          }
        });
        // カウントもリセット
        fillCount = 0;
        fillCountText.setAttribute('value', `埋めた数: 0 / ${count}`);
        // タイマーもリセット
        startTime = null;
        endTime = null;
        timerRunning = false;
        timerText.setAttribute('value', 'time: 0.00秒');
        // 速度表示もリセット
        speedText.setAttribute('value', 'speed: 0.00 個/s');
        // グラフ履歴リセット
        speedHistory = [];
        timeHistory = [];
        updateGraph();
      });

      // 棒のエンティティ取得
      const rightHand = document.getElementById('rightHand');
      const stickTip = document.getElementById('stickTip');

      // お手本ボタンの処理
      document.getElementById('demo-btn').addEventListener('click', function () {
        document.getElementById('reset-btn').click();

        const pieces = Array.from(document.querySelectorAll('[fill-gap-on-mousedown]'));
        let i = 0;

        function fillNext() {
          if (i >= pieces.length) {
            // 終了時に棒を元の位置に戻す
            rightHand.setAttribute('position', '0 1.05 -3.5');
            return;
          }
          const comp = pieces[i].components['fill-gap-on-mousedown'];
          if (comp && !comp.filled) {
            // ピースの位置を取得
            const pos = pieces[i].getAttribute('position');
            // 棒の根本をピースの真上より手前に移動（z+0.3に変更）
            rightHand.setAttribute('position', `${pos.x} 1.11 ${pos.z + 0.34}`);
            setTimeout(() => {
              comp.el.emit('mousedown');
              i++;
              setTimeout(fillNext, 200);
            }, 1);
          } else {
            i++;
            fillNext();
          }
        }

        // 棒を最初のピースの上に移動してから開始
        if (pieces.length > 0) {
          const pos = pieces[0].getAttribute('position');
          rightHand.setAttribute('position', `${pos.x} 1.11 ${pos.z + 0.3}`);
          setTimeout(fillNext, 500);
        }
      });

      graphPlane.addEventListener('loaded', function () {
        const mesh = graphPlane.getObject3D('mesh');
        if (mesh) {
          // CanvasTextureを作成して貼り付け
          const texture = new THREE.CanvasTexture(graphCanvas);
          mesh.material.map = texture;
          mesh.material.needsUpdate = true;
        }
      });
    </script>
    <script>
AFRAME.registerComponent('tablecam-to-screen', {
  init: function () {
    const el = this.el;
    const sceneEl = el.sceneEl;
    this.rt = new THREE.WebGLRenderTarget(512, 512);
    this.tableCam = null;
    this.screen = null;
    this.renderer = null;
    this.threeScene = null;

    // 必要なオブジェクトが取得できるまでリトライ
    const setup = () => {
      this.tableCam = document.getElementById('table-cam').getObject3D('camera');
      this.screen = el.getObject3D('mesh');
      this.renderer = sceneEl.renderer;
      this.threeScene = sceneEl.object3D;
      if (!this.tableCam || !this.screen || !this.renderer) {
        setTimeout(setup, 100);
        return;
      }
    };
    setup();
  },
  tick: function (time, delta) {
    if (!this.tableCam || !this.screen || !this.renderer) return;

    // リプレイ中
    if (replaying && recordedFrames.length > 0) {
      if (!this.replayImg) {
        this.replayImg = new window.Image();
        this.replayTexture = new THREE.Texture(this.replayImg);
        this.screen.material.map = this.replayTexture;
      }
      // リプレイ再生間隔を33ms→20msに
      if (performance.now() - replayLastTime > 20) {
        replayFrameIndex++;
        replayLastTime = performance.now();
        if (replayFrameIndex >= recordedFrames.length) {
          replaying = false;
          replayFrameIndex = 0;
          // ★ ここでリプレイ用のImageとTextureをリセット
          this.replayImg = null;
          this.replayTexture = null;
          return;
        }
        this.replayImg.src = recordedFrames[replayFrameIndex];
      }
      this.replayImg.onload = () => {
        this.replayTexture.needsUpdate = true;
      };
      return;
    }

    // 通常はリアルタイム映像
    this.renderer.setRenderTarget(this.rt);
    this.renderer.render(this.threeScene, this.tableCam);
    this.renderer.setRenderTarget(null);

    // 録画中なら「机カメラの映像」を保存
    if (recording) {
      if (!this.tmpCanvas) {
        this.tmpCanvas = document.createElement('canvas');
        this.tmpCanvas.width = 512;
        this.tmpCanvas.height = 512;
        this.tmpCtx = this.tmpCanvas.getContext('2d');
        this.tmpPixels = new Uint8Array(4 * 512 * 512);
      }
      // WebGLからピクセルを取得
      this.renderer.readRenderTargetPixels(this.rt, 0, 0, 512, 512, this.tmpPixels);
      // ImageDataに変換
      const imageData = this.tmpCtx.createImageData(512, 512);
      imageData.data.set(this.tmpPixels);
      this.tmpCtx.putImageData(imageData, 0, 0);
      // 画像として保存
      recordedFrames.push(this.tmpCanvas.toDataURL());
    }

    this.screen.material.map = this.rt.texture;
    this.screen.material.needsUpdate = true;
  }
});
</script>
<script>
AFRAME.registerComponent('sidecam-to-screen', {
  init: function () {
    const el = this.el;
    const sceneEl = el.sceneEl;
    this.rt = new THREE.WebGLRenderTarget(512, 512);
    this.sideCam = null;
    this.screen = null;
    this.renderer = null;
    this.threeScene = null;

    const setup = () => {
      this.sideCam = document.getElementById('side-cam').getObject3D('camera');
      this.screen = el.getObject3D('mesh');
      this.renderer = sceneEl.renderer;
      this.threeScene = sceneEl.object3D;
      if (!this.sideCam || !this.screen || !this.renderer) {
        setTimeout(setup, 100);
        return;
      }
    };
    setup();
  },
  tick: function (time, delta) {
    if (!this.sideCam || !this.screen || !this.renderer) return;

    // リプレイ中
    if (sideReplaying && sideRecordedFrames.length > 0) {
      if (!this.replayImg) {
        this.replayImg = new window.Image();
        this.replayTexture = new THREE.Texture(this.replayImg);
        this.screen.material.map = this.replayTexture;
      }
      // リプレイ再生間隔を33ms→20msに
      if (performance.now() - sideReplayLastTime > 20) {
        sideReplayFrameIndex++;
        sideReplayLastTime = performance.now();
        if (sideReplayFrameIndex >= sideRecordedFrames.length) {
          sideReplaying = false;
          sideReplayFrameIndex = 0;
          this.replayImg = null;
          this.replayTexture = null;
          return;
        }
        this.replayImg.src = sideRecordedFrames[sideReplayFrameIndex];
      }
      this.replayImg.onload = () => {
        this.replayTexture.needsUpdate = true;
      };
      return;
    }

    // 通常はリアルタイム映像
    this.renderer.setRenderTarget(this.rt);
    this.renderer.render(this.threeScene, this.sideCam);
    this.renderer.setRenderTarget(null);

    // 録画中なら「横カメラの映像」を保存
    if (sideRecording) {
      if (!this.tmpCanvas) {
        this.tmpCanvas = document.createElement('canvas');
        this.tmpCanvas.width = 512;
        this.tmpCanvas.height = 512;
        this.tmpCtx = this.tmpCanvas.getContext('2d');
        this.tmpPixels = new Uint8Array(4 * 512 * 512);
        // 反転用キャンバス
        this.flipCanvas = document.createElement('canvas');
        this.flipCanvas.width = 512;
        this.flipCanvas.height = 512;
        this.flipCtx = this.flipCanvas.getContext('2d');
      }
      this.renderer.readRenderTargetPixels(this.rt, 0, 0, 512, 512, this.tmpPixels);
      const imageData = this.tmpCtx.createImageData(512, 512);
      imageData.data.set(this.tmpPixels);
      // まず通常通り描画
      this.tmpCtx.putImageData(imageData, 0, 0);

      // 反転用キャンバスにY軸反転コピー
      this.flipCtx.save();
      this.flipCtx.clearRect(0, 0, 512, 512);
      this.flipCtx.scale(1, -1);
      this.flipCtx.drawImage(this.tmpCanvas, 0, -512);
      this.flipCtx.restore();

      // 反転済み画像を保存
      sideRecordedFrames.push(this.flipCanvas.toDataURL());
    }

    this.screen.material.map = this.rt.texture;
    this.screen.material.needsUpdate = true;
  }
});
</script>
<script>
// グローバル変数
let recording = false;
let replaying = false;
let recordedFrames = [];
let replayFrameIndex = 0;
let replayLastTime = 0;

// リプレイボタンのクリックでリプレイ開始
document.getElementById('replay-btn').addEventListener('click', function () {
  if (recordedFrames.length === 0) return;
  replaying = true;
  replayFrameIndex = 0;
  replayLastTime = performance.now();
});
// グローバル変数（sidecam用）
let sideRecording = false;
let sideReplaying = false;
let sideRecordedFrames = [];
let sideReplayFrameIndex = 0;
let sideReplayLastTime = 0;

// リプレイボタンのクリックでsidecamリプレイも開始
document.getElementById('replay-btn').addEventListener('click', function () {
  if (sideRecordedFrames.length === 0) return;
  sideReplaying = true;
  sideReplayFrameIndex = 0;
  sideReplayLastTime = performance.now();
});
</script>
<script>
function spawnParticles(x, y, z) {
  const scene = document.querySelector('a-scene');
  // 球体パーティクル（大きく飛ばす）
  for (let i = 0; i < 10; i++) {
    const particle = document.createElement('a-sphere');
    particle.setAttribute('radius', 0.02 + Math.random() * 0.02);
    particle.setAttribute('color', '#fff');
    particle.setAttribute('material', 'opacity:0.8; emissive:#fff; emissiveIntensity:1');
    particle.setAttribute('position', `${x} ${y} ${z}`);
    // ★ 飛び散る距離をとても大きく
    const dx = (Math.random() - 0.5) * 2.5;
    const dy = Math.random() * 1.2 + 0.5;
    const dz = (Math.random() - 0.5) * 2.5;
    scene.appendChild(particle);

    particle.setAttribute('animation__move', {
      property: 'position',
      to: `${x + dx} ${y + dy} ${z + dz}`,
      dur: 600,
      easing: 'ease-out'
    });
    particle.setAttribute('animation__fade', {
      property: 'material.opacity',
      to: 0,
      dur: 600,
      easing: 'linear'
    });
    setTimeout(() => {
      if (particle.parentNode) particle.parentNode.removeChild(particle);
    }, 650);
  }

  // 光の板パーティクル（大きく飛ばす）
  for (let i = 0; i < 10; i++) {
    const sparkle = document.createElement('a-plane');
    sparkle.setAttribute('width', 0.05 + Math.random() * 0.03);
    sparkle.setAttribute('height', 0.05 + Math.random() * 0.03);
    sparkle.setAttribute('color', '#fff');
    sparkle.setAttribute('material', 'opacity:0.7; side:double; transparent:true; emissive:#fff; emissiveIntensity:2');
    sparkle.setAttribute('position', `${x} ${y} ${z}`);
    sparkle.setAttribute('rotation', `${Math.random()*360} ${Math.random()*360} ${Math.random()*360}`);
    // ★ 飛び散る距離をとても大きく
    const dx = (Math.random() - 0.5) * 3.0;
    const dy = Math.random() * 1.5 + 0.7;
    const dz = (Math.random() - 0.5) * 3.0;
    scene.appendChild(sparkle);

    sparkle.setAttribute('animation__move', {
      property: 'position',
      to: `${x + dx} ${y + dy} ${z + dz}`,
      dur: 600,
      easing: 'ease-out'
    });
    sparkle.setAttribute('animation__fade', {
      property: 'material.opacity',
      to: 0,
      dur: 600,
      easing: 'linear'
    });
    setTimeout(() => {
      if (sparkle.parentNode) sparkle.parentNode.removeChild(sparkle);
    }, 650);
  }
}
</script>
<script>
// カメラのz座標が-4より小さく（奥へ）行けないように制限
AFRAME.registerComponent('camera-z-limit', {
  tick: function () {
    const pos = this.el.getAttribute('position');
    // zが-4より小さくなったら-4に戻す
    if (pos.z < -3.2) {
      this.el.setAttribute('position', {x: pos.x, y: pos.y, z: -3.2});
    }
  }
});
    </script>
  </body>
</html>
